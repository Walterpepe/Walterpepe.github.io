<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="李玉的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李玉的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李玉的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>李玉的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李玉的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/ch12/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/ch12/" itemprop="url">ch12</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-29T17:19:07+08:00">
                2019-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h2><p>首先一定要清楚地意识到：『并行编程不简单』！最主要的原因恐怕就是我们自己的大脑，人脑实际上是一个非常精妙的系统，所采取的并行策略是一明一暗两条线，但是对于明线来说，是线性的，于是就和计算机中并行的概念冲突了。另外时间这个概念也是线性的，这就导致了想要处理好并行程序可能出现的各种问题几乎是不可能的（或者常常要出错）。</p>
<p>常见的错误有仨：竞争条件[2]、死锁[3]和活锁[4]，尤其是在现在的多核处理器架构中，更容易出现这类并行问题。</p>
<p>我们前面实现的服务器，一次只能处理一个请求，只有当前的请求处理完了，才能继续处理下一个。</p>
<p><img src="14620201714327.jpg" alt="img"></p>
<p>这里具体讲解一下：Client 1 向 Server 发送连接请求(connect)，Server 接受(accept)之后开始等待 Client 1 发送请求（也就是开始 read），这之后 Client 1 发送具体的内容(write)后转为等待响应(call read)，Server 的 read 接收到了内容之后，发送响应(write) 后仅需进入等待(read)，而 Client 1 接收到了响应(ret read)，最后根据用户指令退出(close)。</p>
<p>而只有当 Client 1 断开之后，Server 才会处理 Client 2 的请求，从图中也可以看到这一点。具体是在哪里等待呢？因为 TCP 会缓存，所以实际上 Client 2 在 <code>ret read</code> 之前进行等待，为了解决这个问题，我们可以使用并行的策略，同时处理不同客户端发来的请求。</p>
<p>总体来说，根据系统机制的层级和实现方式，有下面三大类方法：</p>
<ol>
<li>基于进程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个进程有其私有的地址空间（也就是说进程切换的时候需要保存和载入数据）</li>
</ul>
</li>
<li>基于事件<ul>
<li>由程序员手动控制多个逻辑流</li>
<li>所有的逻辑流共享同一个地址空间</li>
<li>这个技术称为 I/O multiplexing</li>
</ul>
</li>
<li>基于线程<ul>
<li>内核自动管理多个逻辑流</li>
<li>每个线程共享地址空间</li>
<li>属于基于进程和基于事件的混合体</li>
</ul>
</li>
</ol>
<h3 id="基于进程"><a href="#基于进程" class="headerlink" title="基于进程"></a>基于进程</h3><p>为每个客户端分离出一个单独的进程，是建立了连接之后才开始并行，连接的建立还是串行的。</p>
<p>具体的代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)&#123;</span><br><span class="line">    while (waitpid(-1, 0, WNOHANG) &gt; 0)</span><br><span class="line">        ;</span><br><span class="line">    return;</span><br><span class="line">    // Reap all zombie children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        if (Fork() == 0) &#123;</span><br><span class="line">            Close(listenfd); // Child closes its listening socket</span><br><span class="line">            echo(connfd); // Child services client</span><br><span class="line">            Close(connfd); // Child closes connection with client</span><br><span class="line">            exit(0); // Child exits</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); // Parent closes connected socket (important!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>这里用文字描述一下流程：首先，服务器在 <code>accept</code> 函数中（对应 <code>listenfd</code>）等待连接请求，然后客户端通过调用 <code>connect</code> 函数发送连接请求，最后服务器在 <code>accept</code> 中返回 <code>connfd</code> 并且 fork 一个子进程来处理客户端连接，连接建立在 <code>listenfd</code> 和 <code>connfd</code> 间。</p>
<p>整个执行模型中：</p>
<ul>
<li><p>每个客户端由独立子进程处理</p>
<ul>
<li>必须回收僵尸进程，来避免严重的内存泄露</li>
</ul>
</li>
<li><p>不同进程之间不共享数据</p>
</li>
<li><p>父进程和子进程都有</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listenfd</span><br></pre></td></tr></table></figure>
<p>  和</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connfd</span><br></pre></td></tr></table></figure>
<p>  ，所以在父进程中需要关闭</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connfd</span><br></pre></td></tr></table></figure>
<p>  ，在子进程中需要关闭</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listenfd</span><br></pre></td></tr></table></figure>
<ul>
<li>内核会保存每个 socket 的引用计数，在 fork 之后 <code>refcnt(connfd) = 2</code>，所以在父进程需要关闭 connfd，这样在子进程结束后引用计数才会为零</li>
</ul>
<p>基于进程的方式可以并行处理连接，除了共享已打开的 file table 外，无论是 descriptor 还是全局变量都不共享，不大容易造成同步问题，比较简单粗暴。但是带来了额外的进程管理开销，并且进程间通讯不便，需要使用 IPC (interprocess communication)。</p>
<h3 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h3><p>服务器会维护一个 connection 数组，包含若干 <code>connfd</code>，每个输入请求都被当做事件，然后每次从已有的事件中选取一个进行处理。</p>
<p>基于实践的好处在于只使用一个逻辑控制流和地址空间，可以利用调试器进行单步调试（其他的方法因为并行的缘故基本没办法调试），也不会有进程/线程控制的开销。但是相比之下，代码的逻辑复杂度会比较高，很难进行精细度比较高的并行，也无法发挥多核处理器的全部性能。</p>
<h3 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h3><p>和基于进程的方法非常相似，唯一的区别是这里用线程。进程其实是比较『重』的，一个进程包括进程上下文、代码、数据和栈。如果从线程的角度来描述，一个进程则包括线程、代码、数据和上下文。也就是说，线程作为单独可执行的部分，被抽离出来了，一个进程可以有多个线程。</p>
<p>每个线程有自己的线程 id，有自己的逻辑控制流，也有自己的用来保存局部变量的栈（其他线程可以修改）但是会共享所有的代码、数据以及内核上下文。</p>
<p>和进程不同的是，线程没有一个明确的树状结构（使用 <code>fork</code> 是有明确父进程子进程区分的）。和进程中『并行』的概念一样，如果两个线程的控制流在时间上有『重叠』（或者说有交叉），那么就是并行的。</p>
<p>进程和线程的差别已经被说了太多次，这里简单提一下。相同点在于，它们都有自己的逻辑控制流，可以并行，都需要进行上下文切换。不同点在于，线程共享代码和数据（进程通常不会），线程开销比较小（创建和回收）</p>
<p><strong>POSIX Threads</strong></p>
<p>Pthreads 是一个线程库，基本上只要是 C 程序能跑的平台，都会支持这个标准。Pthreads定义了一套C语言的类型、函数与常量，它以 <code>pthread.h</code> 头文件和一个线程库实现。</p>
<p>Pthreads API 中大致共有 100 个函数调用，全都以 <code>pthread_</code> 开头，并可以分为四类：</p>
<ol>
<li>线程管理，例如创建线程，等待(join)线程，查询线程状态等。</li>
<li>Mutex：创建、摧毁、锁定、解锁、设置属性等操作</li>
<li>条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作</li>
<li>使用了读写锁的线程间的同步管理</li>
</ol>
<p>POSIX 的 Semaphore API 可以和 Pthreads 协同工作，但这并不是 Pthreads 的标准。因而这部分API是以 <code>sem_</code> 打头，而非 <code>pthread_</code>。</p>
<p>我们用线程的方式重写一次之前的 Echo Server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Thread routine</span><br><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    int connf = *((int *)vargp);</span><br><span class="line">    // detach 之后不用显式 join，会在执行完毕后自动回收</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    echo(connfd);</span><br><span class="line">    // 一定要记得关闭！</span><br><span class="line">    Close(connfd);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, *connfdp;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        // 这里使用新分配的 connected descriptor 来避免竞争条件</span><br><span class="line">        connfdp = Malloc(sizeof(int));</span><br><span class="line">        *connfdp = Accept(listenfd, (SA *) &amp; clientaddr, &amp;clientlen);</span><br><span class="line">        Pthread_create(&amp;tid, NULL, thread, connfdp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>在这个模型中，每个客户端由单独的线程进行处理，这些线程除了线程 id 之外，共享所有的进程状态（但是每个线程有自己的局部变量栈）。</p>
<p>使用线程并行，能够在不同的线程见方便地共享数据，效率也比进程高，但是共享变量可能会造成比较难发现的程序问题，很难调试和测试。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这里简单归纳下三种并行方法的特点：</p>
<ul>
<li>基于进程<ul>
<li>难以共享资源，但同时也避免了可能带来的共享问题</li>
<li>添加/移除进程开销较大 </li>
</ul>
</li>
<li>基于事件<ul>
<li>非常底层的实现机制</li>
<li>使用全局控制而非调度</li>
<li>开销比较小</li>
<li>但是无法提供精细度较高的并行</li>
<li>无法充分利用多核处理器 </li>
</ul>
</li>
<li>基于线程<ul>
<li>容易共享资源，但也容易出现问题</li>
<li>开销比进程小</li>
<li>对于具体的调度可控性较低</li>
<li>难以调试（因为事件发生的顺序不一致）</li>
</ul>
</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>在介绍同步之前，我们需要弄清楚一个定义，什么是 Shared variable（共享变量）？</p>
<blockquote>
<p>A variable <code>x</code> is <em>shared</em> if and only if multiple threads reference some instance of <code>x</code></p>
</blockquote>
<p>另外一个需要注意的是线程的内存模型，因为概念上的模型和实际的模型有一些差异，非常容易导致错误。</p>
<p>在概念上的模型中：</p>
<ul>
<li>多个线程在一个单独进程的上下文中运行</li>
<li>每个线程有单独的线程上下文（线程 ID，栈，栈指针，PC，条件码，GP 寄存器）</li>
<li>所有的线程共享剩下的进程上下文<ul>
<li>Code, data, heap, and shared library segments of the process virtual address space</li>
<li>Open files and installed handlers</li>
</ul>
</li>
</ul>
<p>在实际的模型中，寄存器的值虽然是隔离且被保护的，但是在栈中的值并不是这样的（其他线程也可以访问）。</p>
<p>我们来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">char **ptr; // 全局变量</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long i;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    char *msgs[2] = &#123;</span><br><span class="line">        &quot;Good Day!&quot;,</span><br><span class="line">        &quot;Bad Day!&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ptr = msgs;</span><br><span class="line">for (i = 0; i &lt; 2; i++)</span><br><span class="line">    Pthread_create(&amp;tid, NULL, thread, (void *)i);</span><br><span class="line">Pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    long myid = (long)vargp;</span><br><span class="line">    static int cnt = 0;</span><br><span class="line">    </span><br><span class="line">    // 这里每个线程都可以访问 ptr 这个全局变量</span><br><span class="line">    printf(&quot;[%ld]: %s (cnt=%d)\n&quot;, myid, ptr[myid], ++cnt);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>这里有几个不同类型的变量，我们一一来看一下：</p>
<ul>
<li>全局变量：在函数外声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
<li>局部变量：在函数内声明，且没有用 static 关键字<ul>
<li>每个线程的栈中都保存着对应线程的局部变量</li>
</ul>
</li>
<li>局部静态变量：在函数内用 static 关键字声明的变量<ul>
<li>虚拟内存中有全局唯一的一份实例</li>
</ul>
</li>
</ul>
<p>具体来分析下，一个变量只有在被多个线程引用的时候才算是共享，在这个例子中，共享变量有 <code>ptr</code>, <code>cnt</code> 和 <code>msgs</code>；非共享变量有 <code>i</code> 和 <code>myid</code>。</p>
<h3 id="关键区域-Critical-Section"><a href="#关键区域-Critical-Section" class="headerlink" title="关键区域 Critical Section"></a>关键区域 Critical Section</h3><p>这一部分我们用一个具体的例子来进行讲解，看看如何用多个线程来计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 全局共享变量</span><br><span class="line">volatile long cnt = 0; // 计数器</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    long niters;</span><br><span class="line">    pthread_t tid1, tid2;</span><br><span class="line">    </span><br><span class="line">    niter2 = atoi(argv[1]);</span><br><span class="line">    Pthread_create(&amp;tid1, NULL, thread, &amp;niters);</span><br><span class="line">    Pthread_create(&amp;tid2, NULL, thread, &amp;niters);</span><br><span class="line">    Pthread_join(tid1, NULL);</span><br><span class="line">    Pthread_join(tid2, NULL);</span><br><span class="line">    </span><br><span class="line">    // 检查结果</span><br><span class="line">    if (cnt != (2 * niters))</span><br><span class="line">        printf(&quot;Wrong! cnt=%ld\n&quot;, cnt);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Correct! cnt=%ld\n&quot;, cnt);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>运行之后发现不是每次都出现同样的结果，我们把操作 <code>cnt</code> 的部分抽出来单独看一看：</p>
<p>线程中循环部分的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; niters; i++)</span><br><span class="line">    cnt++;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>对应的汇编代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    # 以下四句为 Head 部分，记为 H</span><br><span class="line">    movq    (%rdi), %rcx</span><br><span class="line">    testq   %rcx, %rcx</span><br><span class="line">    jle     .L2</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">.L3:</span><br><span class="line">    movq    cnt(%rip), %rdx # 载入 cnt，记为 L</span><br><span class="line">    addq    $1, %rdx        # 更新 cnt，记为 U</span><br><span class="line">    movq    %rdx, cnt(%rip) # 保存 cnt，记为 S</span><br><span class="line">    # 以下为 Tail 部分，记为 T</span><br><span class="line">    addq    $1, %rax</span><br><span class="line">    cmpq    %rcx, %rax</span><br><span class="line">    jne     .L3</span><br><span class="line">.L2:</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>这里有一点需要注意，<code>cnt</code> 使用了 <code>volatile</code> 关键字声明，意思是不要在寄存器中保存值，无论是读取还是写入，都要对内存操作（还记得 write-through 吗？）。这里把具体的步骤分成 5 步：HLUST，尤其要注意 LUS 这三个操作，这三个操作必须在一次执行中完成，一旦次序打乱，就会出现问题，不同线程拿到的值就不一定是最新的。</p>
<p>更多相关内容，可以参考<a href="http://wdxtub.com/vault/csapp-23.html" target="_blank" rel="noopener">Synchronization - Basics</a>，其中提到了利用图表来描述关键区域的方法，感兴趣可以看一下。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>针对关键区域的问题，我们可以考虑用信号量来限制程序的执行顺序。计数信号量具备两种操作动作，称为 V（又称signal()）与 P（wait()）。 V 操作会增加信号量 S 的数值，P 操作会减少。运作方式：</p>
<ol>
<li>初始化，给与它一个非负数的整数值。</li>
<li>运行 P，信号量 S 的值将被减少。企图进入临界区块的进程，需要先运行 P。当信号量 S 减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。</li>
<li>运行 V，信号量 S 的值会被增加。结束离开临界区块的进程，将会运行 V。当信号量 S 不为负值时，先前被挡住的其他进程，将可获准进入临界区块。</li>
</ol>
<p>我们来看看如何修改可以使得前面我们的计数程序正确运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 先定义信号量</span><br><span class="line">volatile long cnt = 0;</span><br><span class="line">sem_t mutex;</span><br><span class="line"></span><br><span class="line">Sem_init(&amp;mutex, 0, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在线程中用 P 和 V 包围关键操作</span><br><span class="line">for (i = 0; i &lt; niters; i++)</span><br><span class="line">&#123;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>在使用线程时，脑中需要有一个清晰的分享变量的概念，共享变量需要互斥访问，而 Semaphores 是一个基础的机制。</p>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p><img src="14620251080738.jpg" alt="img"></p>
<p>具体的同步模型为：</p>
<ul>
<li>生产者等待空的 slot，把 item 存储到 buffer，并通知消费者</li>
<li>消费整等待 item，从 buffer 中移除 item，并通知生产者</li>
</ul>
<p>主要用于</p>
<ul>
<li>多媒体处理<ul>
<li>生产者生成 MPEG 视频帧，消费者进行渲染</li>
</ul>
</li>
<li>事件驱动的图形用户界面<ul>
<li>生产者检测到鼠标点击、移动和键盘输入，并把对应的事件插入到 buffer 中</li>
<li>消费者从 buffer 中获取事件，并绘制到到屏幕上</li>
</ul>
</li>
</ul>
<p>接下来我们实现一个有 n 个元素 buffer，为此，我们需要一个 mutex 和两个用来计数的 semaphore：</p>
<ul>
<li><code>mutex</code>: 用来保证对 buffer 的互斥访问</li>
<li><code>slots</code>: 统计 buffer 中可用的 slot 数目</li>
<li><code>items</code>: 统计 buffer 中可用的 item 数目</li>
</ul>
<p>我们直接来看代码，就比较清晰了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 头文件 sbuf.h</span><br><span class="line">// 包括几个基本操作</span><br><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    int *buf;    // Buffer array</span><br><span class="line">    int n;       // Maximum number of slots</span><br><span class="line">    int front;   // buf[(front+1)%n] is first item</span><br><span class="line">    int rear;    // buf[rear%n] is the last item</span><br><span class="line">    sem_t mutex; // Protects accesses to buf</span><br><span class="line">    sem_t slots; // Counts available slots</span><br><span class="line">    sem_t items; // Counts available items</span><br><span class="line">&#125; sbuf_t;</span><br><span class="line"></span><br><span class="line">void sbuf_init(sbuf_t *sp, int n);</span><br><span class="line">void sbuf_deinit(sbuf_t *sp);</span><br><span class="line">void sbuf_insert(sbuf_t *sp, int item);</span><br><span class="line">int sbuf_remove(sbuf_t *sp);</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>然后是具体的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// sbuf.c</span><br><span class="line"></span><br><span class="line">// Create an empty, bounded, shared FIFO buffer with n slots</span><br><span class="line">void sbuf_init(sbuf_t *sp, int n) &#123;</span><br><span class="line">    sp-&gt;buf = Calloc(n, sizeof(int));</span><br><span class="line">    sp-&gt;n = n;                  // Buffer holds max of n items</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = 0;   // Empty buffer iff front == rear</span><br><span class="line">    Sem_init(&amp;sp-&gt;mutex, 0, 1); // Binary semaphore for locking</span><br><span class="line">    Sem_init(&amp;sp-&gt;slots, 0, n); // Initially, buf has n empty slots</span><br><span class="line">    Sem_init(&amp;sp-&gt;items, 0, 0); // Initially, buf has 0 items</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Clean up buffer sp</span><br><span class="line">void sbuf_deinit(sbuf_t *sp)&#123;</span><br><span class="line">    Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Insert item onto the rear of shared buffer sp</span><br><span class="line">void sbuf_insert(sbuf_t *sp, int item) &#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                        // Wait for available slot</span><br><span class="line">    P(&amp;sp-&gt;mutext);                       // Lock the buffer</span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item; // Insert the item</span><br><span class="line">    V(&amp;sp-&gt;mutex);                        // Unlock the buffer</span><br><span class="line">    V(&amp;sp-&gt;items);                        // Announce available item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove and return the first tiem from the buffer sp</span><br><span class="line">int sbuf_remove(sbuf_f *sp) &#123;</span><br><span class="line">    int item;</span><br><span class="line">    P(&amp;sp-&gt;items);                         // Wait for available item</span><br><span class="line">    P(&amp;sp-&gt;mutex);                         // Lock the buffer</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)]; // Remove the item</span><br><span class="line">    V(&amp;sp-&gt;mutex);                         // Unlock the buffer</span><br><span class="line">    V(&amp;sp-&gt;slots);                         // Announce available slot</span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>是互斥问题的通用描述，具体为：</p>
<ul>
<li>读者线程只读取对象</li>
<li>写者线程修改对象</li>
<li>写者对于对象的访问是互斥的</li>
<li>多个读者可以同时读取对象</li>
</ul>
<p>常见的应用场景是：</p>
<ul>
<li>在线订票系统</li>
<li>多线程缓存 web 代理</li>
</ul>
<p>根据不同的读写策略，又两类读者写者问题，需要注意的是，这两种情况都可能出现 starvation。</p>
<blockquote>
<p>第一类读者写者问题（读者优先）</p>
</blockquote>
<ul>
<li>如果写者没有获取到使用对象的权限，不应该让读者等待</li>
<li>在等待的写者之后到来的读者应该在写者之前处理</li>
<li>也就是说，只有没有读者的情况下，写者才能工作</li>
</ul>
<blockquote>
<p>第二类读者写者问题（写者优先）</p>
</blockquote>
<ul>
<li>一旦写者可以处理的时候，就不应该进行等待</li>
<li>在等待的写者之后到来的读者应该在写者之后处理</li>
</ul>
<p>具体的代码为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">sbuf_t sbuf; // Shared buffer of connected descriptors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int byte_cnt;  // Byte counter</span><br><span class="line">static sem_t mutex;   // and the mutex that protects it</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void echo_cnt(int connfd)&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    rio_t rio;</span><br><span class="line">    static pthread_once_t once = PTHREAD_ONCE_INIT;</span><br><span class="line">    </span><br><span class="line">    Pthread_once(&amp;once, init_echo_cnt);</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        byte_cnt += n;</span><br><span class="line">        printf(&quot;thread %d received %d (%d total) bytes on fd %d\n&quot;,</span><br><span class="line">                    (int) pthread_self(), n, byte_cnt, connfd);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void init_echo_cnt(void)&#123;</span><br><span class="line">    Sem_init(&amp;mutex, 0, 1);</span><br><span class="line">    byte_cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        int connfd = sbuf_remove(&amp;sbuf); // Remove connfd from buf</span><br><span class="line">        echo_cnt(connfd);                // Service client</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int i, listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    for (i = 0; i &lt; NTHREADS; i++) // Create worker threads</span><br><span class="line">        Pthread_create(&amp;tid, NULL, thread, NULL);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        sbuf_insert(&amp;sbuf, connfd); // Insert connfd in buffer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在线程中调用的函数必须是线程安全的，定义为：</p>
<blockquote>
<p>A function is thread-safe iff it will always produce correct results when called repeatedly from multiple concurrent threads</p>
</blockquote>
<p>主要有 4 类线程不安全的函数</p>
<ol>
<li>不保护共享变量的函数<ul>
<li>解决办法：使用 P 和 V semaphore 操作</li>
<li>问题：同步操作会影响性能</li>
</ul>
</li>
<li>在多次调用间保存状态的函数<ul>
<li>解决办法：把状态当做传入参数</li>
</ul>
</li>
<li>返回指向静态变量的指针的函数<ul>
<li>解决办法1：重写函数，传地址用以保存</li>
<li>解决办法2：上锁，并且进行复制</li>
</ul>
</li>
<li>调用线程不安全函数的函数<ul>
<li>解决办法：只调用线程安全的函数</li>
</ul>
</li>
</ol>
<p>另一个重要的概念是 Reentrant Function，定义为：</p>
<blockquote>
<p>A function is <strong>reentrant</strong> iff it accesses no shared variables when called by multiple threads</p>
</blockquote>
<p>Reentrant Functions 是线程安全函数非常重要的子集，不需要同步操作，对于第二类的函数来说（上面提到的），唯一的办法就是把他们修改成 reentrant 的。</p>
<p>标准 C 库中的函数都是线程安全的（如 <code>malloc</code>, <code>free</code>, <code>printf</code>, <code>scanf</code>），大多数 Unix 的系统调用也都是线程安全的。</p>
<p>总结来看，并行编程需要注意的是：</p>
<ul>
<li>要有并行策略，可以把一个大任务分成若干个独立的子任务，或者用分而治之的方式来解决</li>
<li>内循环最好不要有任何同步机制</li>
<li>注意 Amdahl’s Law</li>
<li>一致性是个大问题，无论是计算一致性还是存储一致性，都需要仔细考虑</li>
</ul>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>回想一下，我们之前是如何处理 I/O 的延迟的呢？一个办法是每个客户端都由一个线程来处理，这样就不需要互相等待。现在的多核/超线程处理器提供了另外一种可能。我们不但可以并行执行多个线程，更好的是这些都是自动进行的，当然，我们也可以通过把大任务分成小任务来加速运算。</p>
<p><img src="14620327073816.jpg" alt="img"></p>
<p>上图是典型的多核处理器架构，这里需要注意的是 L3 缓存（图上没有显示）和主内存都是共享的。而具体的执行计算的架构，基本的乱序执行处理器的架构为：</p>
<p><img src="https://wdxtub.com/images/14601450728106.jpg" alt="Out-of-Order Processor Structure"></p>
<p>指令控制器会动态把程序转换成操作流，操作会被映射到 Functional Unit 上进行并行处理。这种情况下，一个核心处理一个线程。而在超线程的设计中，一个核心可以处理若干个线程，秘诀在于多出来了若干套指令控制流，如下图：</p>
<p><img src="https://wdxtub.com/images/14601452084625.jpg" alt="Hyperthreading Implementation"></p>
<p>如果我们想要了解机器的相关信息，可以访问 <code>/proc/cpuinfo</code></p>
<p><img src="https://wdxtub.com/images/14601453998378.jpg" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/ch11/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/ch11/" itemprop="url">ch11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-29T17:17:47+08:00">
                2019-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><p>计算机网络的知识可谓是非常『保值』的，因为这么多基础设备还在运行着，基本机制在短时间内很难改变，关于网络的相关的讲解还有参考链接[1][2]，我觉得也非常不错，大家感兴趣可以看看。</p>
<p>客户端-服务器模型是网络应用最广泛使用的模型，客户端进程发送请求给服务器进程，服务器进程获取所需资源并响应客户端进程的请求，客户端进程收到响应后展示给用户。网络相关的处理，都是通过网络适配器来完成的，具体在硬件上为（右下角）：</p>
<p><img src="14619458669883.jpg" alt="img"></p>
<p>根据网络的应用范围和架构层级，可以分成三个部分：</p>
<ul>
<li>SAN - System Area Network<ul>
<li>Switched Ethernet, Quadrics QSW, …</li>
</ul>
</li>
<li>LAN - Local Area Network<ul>
<li>Ethernet, ..</li>
</ul>
</li>
<li>WAN - Wide Area Network<ul>
<li>High speed point-to-point phone lines</li>
</ul>
</li>
</ul>
<h3 id="最底层-Ethernet-Segment"><a href="#最底层-Ethernet-Segment" class="headerlink" title="最底层 - Ethernet Segment"></a>最底层 - Ethernet Segment</h3><p>由若干主机(hosts)通过交换机(hub)连接，通常范围是房间或一层楼，如下图所示：</p>
<p><img src="14619464142056.jpg" alt="img"></p>
<ul>
<li>每个 Ethernet 适配器有一个唯一的 48 位的地址（也就是 MAC 地址），例如 <code>00:16:ea:e3:54:e6</code></li>
<li>不同主机间发送的数据称为帧(frame)</li>
<li>Hub 会把每个端口发来的所有数据复制到其他的端口<ul>
<li>所有的主机都可以看到所有的数据（注意安全问题）</li>
</ul>
</li>
</ul>
<h3 id="下一层-Bridged-Ethernet-Segment"><a href="#下一层-Bridged-Ethernet-Segment" class="headerlink" title="下一层 - Bridged Ethernet Segment"></a>下一层 - Bridged Ethernet Segment</h3><p>通常范围是一层楼，通过不同的 bridge 来连接不同的 ethernet segment。Bridge 知道从某端口出发可达的主机，并有选择的在端口间复制数据。</p>
<p><img src="14619467342899.jpg" alt="img"></p>
<p>为了从概念上简化，我们可以认为，所有的 hub, bridge 可以抽象为一条线，如下图所示：</p>
<p><img src="14619469077741.jpg" alt="img"></p>
<h3 id="下一层-internets"><a href="#下一层-internets" class="headerlink" title="下一层 - internets"></a>下一层 - internets</h3><p>不同的（也许不兼容）的 LAN 可以通过 router 来进行物理上的连接，这样连接起来的网络称为 internet（注意是小写，大写的 Internet 可以认为是最著名的 internet）</p>
<p><img src="14619471233534.jpg" alt="img"></p>
<p>internet 的逻辑结构为：</p>
<ul>
<li>Ad hoc interconnection of networks<ul>
<li>没有特定的拓扑结构</li>
<li>不同的 router 和 link 差异可能很大</li>
</ul>
</li>
<li>通过在不同的网络间跳转来传递 packet<ul>
<li>Router 是不同网络间的连接</li>
<li>不同的 packet 可能会走不同的路线</li>
</ul>
</li>
</ul>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>在不同的 LAN 和 WAN 中传输数据，就要守规矩，这个规矩就是协议。协议负责做的事情有：</p>
<ul>
<li>提供 naming scheme<ul>
<li>定义 host address 格式</li>
<li>每个主机和路由器都至少有一个独立的 internet 地址</li>
</ul>
</li>
<li>提供 delivery mechanism<ul>
<li>定义了标准的传输单元 - packet</li>
<li>Packet 包含 header 和 payload<ul>
<li>header 包括 packet size, source 和 destination address</li>
<li>payload 包括需要传输的数据 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在这样的协议下，具体的数据传输如下图所示，这里 PH = Internet packet header, FH = LAN frame header（具体名词解释可见参考文末参考资料）：</p>
<p><img src="14619781335872.jpg" alt="img"></p>
<p>Internet 是 internet 最为著名的例子。主要基于 TCP/IP 协议族：</p>
<ul>
<li>IP (Internet Protocal)<ul>
<li>Provides <strong>basic naming scheme</strong> and unreliable <strong>delivery capability</strong> of packets (datagrams) from <strong>host-to-host</strong></li>
</ul>
</li>
<li>UDP (Unreliable Datagram Protocol)<ul>
<li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li>
</ul>
</li>
<li>TCP (Transmission Control Protocol)<ul>
<li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong> over <strong>connections</strong></li>
</ul>
</li>
</ul>
<p>Accessed via a mix of Unix file I/O and functions from <strong>sockets interface</strong>.（很多东西不是很好翻译，用原文比较准确）</p>
<ul>
<li>主机有 32 位的 IP 地址 - 23.235.46.133<ul>
<li>IPv4 - 32 位地址，IPv6 - 128 位地址</li>
</ul>
</li>
<li>IP 地址被映射到域名 - 23.235.46.133 映射到 <a href="http://www.wdxtub.com" target="_blank" rel="noopener">www.wdxtub.com</a></li>
<li>不同主机之间的进程，可以通过 connection 来交换数据</li>
</ul>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>我们会用一个叫做 IP address struct 的东西来存储，并且 IP 地址是以 network byte order（也就是大端）来进行存储的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Internet address structure</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;    // network byte order (big-endian)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>为了方便读，一般用下面的形式来进行表示：</p>
<p>IP 地址：<code>0x8002C2F2 = 128.2.194.242</code></p>
<p>具体的转换可以使用 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数</p>
<h3 id="Internet-域名"><a href="#Internet-域名" class="headerlink" title="Internet 域名"></a>Internet 域名</h3><p>这里主要需要了解的就是 Domain Naming System(DNS) 的概念，用来做 IP 地址到域名的映射。具体可以用 <code>nslookup</code> 命令来查看，下面是一些例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">wdxtub.local</span><br><span class="line"></span><br><span class="line">$ nslookup www.wdxtub.com</span><br><span class="line">Server:		8.8.8.8</span><br><span class="line">Address:	8.8.8.8#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.wdxtub.com	canonical name = wdxtub.github.io.</span><br><span class="line">wdxtub.github.io	canonical name = github.map.fastly.net.</span><br><span class="line">Name:	github.map.fastly.net</span><br><span class="line">Address: 23.235.39.133</span><br><span class="line"></span><br><span class="line">$ nslookup www.twitter.com</span><br><span class="line">Server:		8.8.8.8</span><br><span class="line">Address:	8.8.8.8#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.twitter.com	canonical name = twitter.com.</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 199.16.156.6</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 199.16.156.198</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 199.16.156.230</span><br><span class="line">Name:	twitter.com</span><br><span class="line">Address: 199.16.156.70</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h3 id="Internet-连接"><a href="#Internet-连接" class="headerlink" title="Internet 连接"></a>Internet 连接</h3><p>客户端和服务器通过连接(connection)来发送字节流，特点是：</p>
<ul>
<li>点对点: 连接一对进程</li>
<li>全双工: 数据同时可以在两个方向流动</li>
<li>可靠: 字节的发送的顺序和收到的一致</li>
</ul>
<p>Socket 则可以认为是 connection 的 endpoint，socket 地址是一个 <code>IPaddress:port</code> 对。</p>
<p>Port（端口）是一个 16 位的整数，用来标识不同的进程，利用不同的端口来连接不同的服务：</p>
<ul>
<li><p>Ephemeral port: Assigned automatically by client kernel when client makes a connection request</p>
</li>
<li><p>Well-known port: Associated with some</p>
</li>
</ul>
<p>  service</p>
<p>  provided by a server（在 linux 系统上可以在</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/services</span><br></pre></td></tr></table></figure>
<p>  中查看具体的信息）</p>
<ul>
<li>echo server: 7/echo</li>
<li>ssh server: 22/ssh</li>
<li>email server: 25/smtp</li>
<li>web servers: 80/http</li>
</ul>
<h3 id="Socket-接口"><a href="#Socket-接口" class="headerlink" title="Socket 接口"></a>Socket 接口</h3><p>一系列系统级的函数，和 Unix I/O 配合构造网络应用（在所有的现代操作系统上都可用）。</p>
<p>对于 kernel 来说，socket 是 endpoint of communication；对于应用程序来说，socket 是 file descriptor，用来读写（回忆一下，STDIN 和 STDOUT 也是 file descriptor）。客户端和服务器通过读写对应的 socket descriptor 来进行。</p>
<p>具体连接的过程可以参考下图，注意，这一讲不做过多细节探讨，相信相关信息请参考书本对应内容。</p>
<p><img src="14619808912880.jpg" alt="img"></p>
<h2 id="简单服务器实现"><a href="#简单服务器实现" class="headerlink" title="简单服务器实现"></a>简单服务器实现</h2><h3 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h3><p>写服务器，最重要的就是理清思路，上节课我们介绍了诸多概念，尤其是最后提到的 <code>getaddrinfo</code> 和 <code>getnameinfo</code>，都是我们在搭建过程中必不可少的工具。参考上面的流程图，整个的工作流程有 5 步：</p>
<ol>
<li><p>开启服务器（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_listenfd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   函数，做好接收请求的准备）</p>
<ul>
<li><p><code>getaddrinfo</code>: 设置服务器的相关信息，具体可以参见 图1&amp;2</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket</span><br></pre></td></tr></table></figure>
<p>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</p>
<ul>
<li><code>int socket(int domain, int type, int protocol)</code></li>
<li>例如 <code>int clientfd = socket(AF_INET, SOCK_STREAM, 0);</code></li>
<li><code>AF_INET</code> 表示在使用 32 位 IPv4 地址</li>
<li><code>SOCK_STREAM</code> 表示这个 socket 将是 connection 的 endpoint</li>
<li>前面这种写法是协议相关的，建议使用 <code>getaddrinfo</code> 生成的参数来进行配置，这样就是协议无关的了</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind</span><br></pre></td></tr></table></figure>
<p>: 请求 kernel 把 socket address 和 socket descriptor 绑定</p>
<ul>
<li><code>int bind(int sockfd, SA *addr, socklen_t addrlen);</code></li>
<li>The process can read bytes that arrive on the connection whose endpoint is <code>addr</code> by reading from descriptor <code>sockfd</code></li>
<li>Similarly, writes to <code>sockfd</code> are transferred along connection whose endpoint is <code>addr</code></li>
<li>最好是用 <code>getaddrinfo</code> 生成的参数作为 <code>addr</code> 和 <code>addrlen</code></li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen</span><br></pre></td></tr></table></figure>
<p>: 默认来说，我们从</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket</span><br></pre></td></tr></table></figure>



函数中得到的 descriptor 默认是 active socket（也就是客户端的连接），调用



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen</span><br></pre></td></tr></table></figure>



函数告诉 kernel 这个 socket 是被服务器使用的

- `int listen(int sockfd, int backlog);`
- 把 `sockfd` 从 active socket 转换成 listening socket，用来接收客户端的请求
- `backlog` 的数值表示 kernel 在接收多少个请求之后（队列缓存起来）开始拒绝请求
</code></pre><ul>
<li><p>[*]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept</span><br></pre></td></tr></table></figure>
<p>: 调用</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept</span><br></pre></td></tr></table></figure>



函数，开始等待客户端请求

- `int accept(int listenfd, SA *addr, int *addrlen);`
- 等待绑定到 `listenfd` 的连接接收到请求，然后把客户端的 socket address 写入到 `addr`，大小写入到 `addrlen`
- 返回一个 connected descriptor 用来进行信息传输（类似 Unix I/O）
- 具体的过程可以参考 图3
</code></pre><ol start="2">
<li><p>开启客户端（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_clientfd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   函数，设定访问地址，尝试连接）</p>
<ul>
<li><p><code>getaddrinfo</code>: 设置客户端的相关信息，具体可以参见 图1&amp;2</p>
</li>
<li><p><code>socket</code>: 创建 socket descriptor，也就是之后用来读写的 file descriptor</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect</span><br></pre></td></tr></table></figure>
<p>: 客户端调用</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect</span><br></pre></td></tr></table></figure>



来建立和服务器的连接

- `int connect(int clientfd, SA *addr, socklen_t addrlen);`
- 尝试与在 socker address `addr` 的服务器建立连接
- 如果成功 `clientfd` 可以进行读写
- connection 由 socket 对描述 `(x:y, addr.sin_addr:addr.sin_port)`
- `x` 是客户端地址，`y` 是客户端临时端口，后面的两个是服务器的地址和端口
- 最好是用 `getaddrinfo` 生成的参数作为 `addr` 和 `addrlen`
</code></pre><ol start="3">
<li><p>交换数据（主要是一个流程循环，客户端向服务器写入，就是发送请求；服务器向客户端写入，就是发送响应）</p>
<ul>
<li>[Client]<code>rio_writen</code>: 写入数据，相当于向服务器发送请求</li>
<li>[Client]<code>rio_readlineb</code>: 读取数据，相当于从服务器接收响应</li>
<li>[Server]<code>rio_readlineb</code>: 读取数据，相当于从客户端接收请求</li>
<li>[Server]<code>rio_writen</code>: 写入数据，相当于向客户端发送响应</li>
</ul>
</li>
<li><p>关闭客户端（主要是</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close</span><br></pre></td></tr></table></figure>
<p>   ）</p>
<ul>
<li>[Client]<code>close</code>: 关闭连接</li>
</ul>
<ol start="5">
<li><p>断开客户端（服务接收到客户端发来的 EOF 消息之后，断开已有的和客户端的连接）</p>
<ul>
<li>[Server]<code>rio_readlineb</code>: 收到客户端发来的关闭连接请求</li>
<li>[Server]<code>close</code>: 关闭与客户端的连接</li>
</ul>
</li>
</ol>
<h3 id="Client-open-clientfd"><a href="#Client-open-clientfd" class="headerlink" title="Client open_clientfd"></a>Client <code>open_clientfd</code></h3><p>用来建立和服务器的连接，协议无关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int open_clientfd(char *hostname, char *port) &#123;</span><br><span class="line">    int clientfd;</span><br><span class="line">    struct addrinfo hints, *listp, *p;</span><br><span class="line">    </span><br><span class="line">    // Get a list of potential server address</span><br><span class="line">    memset(&amp;hints, 0, sizeof(struct addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; // Open a connection</span><br><span class="line">    hints.ai_flags = AI_NUMERICSERV; // using numeric port arguments</span><br><span class="line">    hints.ai_flags |= AI_ADDRCONFIG; // Recommended for connections</span><br><span class="line">    getaddrinfo(hostname, port, &amp;hints, &amp;listp);</span><br><span class="line">    </span><br><span class="line">    // Walk the list for one that we can successfully connect to</span><br><span class="line">    // 如果全部都失败，才最终返回失败（可能有多个地址）</span><br><span class="line">    for (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        // Create a socket descriptor</span><br><span class="line">        // 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span><br><span class="line">        if ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; 0)</span><br><span class="line">            continue; // Socket failed, try the next</span><br><span class="line">        </span><br><span class="line">        // Connect to the server</span><br><span class="line">        // 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span><br><span class="line">        if (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != -1)</span><br><span class="line">            break; // Success</span><br><span class="line">        </span><br><span class="line">        close(clientfd); // Connect failed, try another</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Clean up</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    if (!p) // All connections failed</span><br><span class="line">        return -1;</span><br><span class="line">    else // The last connect succeeded</span><br><span class="line">        return clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h3 id="Server-open-listenfd"><a href="#Server-open-listenfd" class="headerlink" title="Server open_listenfd"></a>Server <code>open_listenfd</code></h3><p>创建 listening descriptor，用来接收来自客户端的请求，协议无关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int open_listenfd(char *port)&#123;</span><br><span class="line">    struct addrinfo hints, *listp, *p;</span><br><span class="line">    int listenfd, optval=1;</span><br><span class="line">    </span><br><span class="line">    // Get a list of potential server addresses</span><br><span class="line">    memset(&amp;hints, 0, sizeof(struct addrinfo));</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; // Accept connection</span><br><span class="line">    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; // on any IP address</span><br><span class="line">    hints.ai_flags |= AI_NUMERICSERV; // using port number</span><br><span class="line">    // 因为服务器不需要连接，所以原来填写地址的地方直接是 NULL</span><br><span class="line">    getaddrinfo(NULL, port, &amp;hints, &amp;listp); </span><br><span class="line">    </span><br><span class="line">    // Walk the list for one that we can successfully connect to</span><br><span class="line">    // 如果全部都失败，才最终返回失败（可能有多个地址）</span><br><span class="line">    for (p = listp; p; p = p-&gt;ai_next) &#123;</span><br><span class="line">        // Create a socket descriptor</span><br><span class="line">        // 这里使用从 getaddrinfo 中得到的参数，实现协议无关</span><br><span class="line">        if ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,</span><br><span class="line">                               p-&gt;ai_protocol)) &lt; 0)</span><br><span class="line">            continue; // Socket failed, try the next</span><br><span class="line">        </span><br><span class="line">        // Eliminates &quot;Address already in use&quot; error from bind</span><br><span class="line">        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR), </span><br><span class="line">                    (const void *)&amp;optval, sizeof(int));</span><br><span class="line">        </span><br><span class="line">        // Bind the descriptor to the address</span><br><span class="line">        if (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == 0)</span><br><span class="line">            break; // Success</span><br><span class="line">        </span><br><span class="line">        close(listenfd); // Bind failed, try another</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Clean up</span><br><span class="line">    freeaddrinfo(listp);</span><br><span class="line">    if (!p) // No address worked</span><br><span class="line">        return -1;</span><br><span class="line">    </span><br><span class="line">    // Make it a listening socket ready to accept connection requests</span><br><span class="line">    if (listen(listenfd, LISTENQ) &lt; 0) &#123;</span><br><span class="line">        close(listenfd);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return listenfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h2 id="简单的-socket-服务器实例"><a href="#简单的-socket-服务器实例" class="headerlink" title="简单的 socket 服务器实例"></a>简单的 socket 服务器实例</h2><h3 id="客户端-Echo-Client"><a href="#客户端-Echo-Client" class="headerlink" title="客户端 Echo Client"></a>客户端 Echo Client</h3><p>这个客户端做的事情很简单，就是把一段用户输入的文字发送到服务器，然后再把从服务器接收到的内容显示到输出中，具体可以参见注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// echoclient.c</span><br><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char **argv) &#123;</span><br><span class="line">    int clientfd;</span><br><span class="line">    char *host, *port, buf[MAXLINE];</span><br><span class="line">    rio_t rio;</span><br><span class="line">    </span><br><span class="line">    host = argv[1];</span><br><span class="line">    port = argv[2];</span><br><span class="line">    </span><br><span class="line">    // 建立连接（前面已经详细介绍）</span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    </span><br><span class="line">    while (Fgets(buf, MAXLINE, stdin) != NULL) &#123;</span><br><span class="line">        // 写入，也就是向服务器发送信息</span><br><span class="line">        Rio_writen(clientfd, buf, strlen(buf));</span><br><span class="line">        // 读取，也就是从服务器接收信息</span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        // 把从服务器接收的信息显示在输出中</span><br><span class="line">        Fputs(buf, stdout);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h3 id="服务器-Iterative-Echo-Server"><a href="#服务器-Iterative-Echo-Server" class="headerlink" title="服务器 Iterative Echo Server"></a>服务器 Iterative Echo Server</h3><p>服务器做的工作也很简单，接收到从客户端发送的信息，然后返回一个一模一样的。具体参加注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// echoserveri.c</span><br><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line">void echo(int connfd);</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr; // Enough room for any addr</span><br><span class="line">    char client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line">    </span><br><span class="line">    // 开启监听端口，注意只开这么一次</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 需要具体的大小</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage); // Important!</span><br><span class="line">        // 等待连接</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        // 获取客户端相关信息</span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname,</span><br><span class="line">                     MAXLINE, client_port, MAXLINE, 0);</span><br><span class="line">        printf(&quot;Connected to (%s, %s)\n&quot;, client_hostname, client_port);</span><br><span class="line">        // 服务器具体完成的工作</span><br><span class="line">        echo(coonfd);</span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void echo(int connfd) &#123;</span><br><span class="line">    size_t n;</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    rio_t rio;</span><br><span class="line">    </span><br><span class="line">    // 读取从客户端传输过来的数据</span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    while((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) &#123;</span><br><span class="line">        printf(&quot;server received %d bytes\n&quot;, (int)n);</span><br><span class="line">        // 把从 client 接收到的信息再写回去</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/ch10/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/29/ch10/" itemprop="url">ch10</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-29T17:14:57+08:00">
                2019-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>在 Linux 中，文件实际上可以看做是字节的序列。更有意思的是，所有的 I/O 设备也是用文件来表示的，比如：</p>
<ul>
<li><code>./dev/sda2</code> (<code>/usr</code> 磁盘分区)</li>
<li><code>/dev/tty2</code> (终端)</li>
</ul>
<p>甚至连内核也是用文件来表示的：</p>
<ul>
<li><code>/boot/vmlinuz-3.13.0-55-generic</code> (内核镜像)</li>
<li><code>/proc</code> (内核数据结构)</li>
</ul>
<p>因为 I/O 设备也是文件，所以内核可以利用称为 Unix I/O 的简单接口来处理输入输出，比如使用 <code>open()</code> 和 <code>close()</code> 来打开和关闭文件，使用 <code>read()</code> 和 <code>write()</code> 来读写文件，或者利用 <code>lseek()</code> 来设定读取的偏移量等等。</p>
<p>为了区别不同文件的类型，会有一个 <code>type</code> 来进行区别：</p>
<ul>
<li>普通文件：包含任意数据</li>
<li>目录：相关一组文件的索引</li>
<li>套接字 Socket：和另一台机器上的进程通信的类型</li>
</ul>
<p>其实还有一些比较特别的类型，但是这里提一下，不深入了解：</p>
<ul>
<li>Named pipes(FIFOs)</li>
<li>Symbolic links</li>
<li>Character and block devices</li>
</ul>
<p><strong>普通文件</strong></p>
<p>普通的文件包含任意数据，应用一般来说需要区分出文本文件和二进制文件。文本文件只包含 ASCII 或 Unicode 字符。除此之外的都是二进制文件(对象文件, JPEG 图片, 等等)。对于内核来说其实并不能区分出个中的区别。</p>
<p>文本文件就是一系列的文本行，每行以 <code>\n</code> 结尾，新的一行是 <code>0xa</code>，和 ASCII 码中的 line feed 字符(LF) 一样。不同系统用用判断一行结束的符号不同(End of line, EOL)，如：</p>
<ul>
<li>Linux &amp; Mac OS:</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n</span><br></pre></td></tr></table></figure>
<p>  (0xa)</p>
<ul>
<li>line feed(LF) </li>
</ul>
<ul>
<li>Windows &amp; 网络协议:</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>  (0xd 0xa)</p>
<ul>
<li>Carriage return(CR) followed by line feed(LF)</li>
</ul>
<p><strong>目录</strong></p>
<p>目录包含一个链接(link)数组，并且每个目录至少包含两条记录：</p>
<ul>
<li><code>.</code>(dot) 当前目录</li>
<li><code>..</code>(dot dot) 上一层目录</li>
</ul>
<p>用来操作目录的命令主要有 <code>mkdir</code>, <code>ls</code>, <code>rmdir</code>。目录是以树状结构组织的，根目录是 <code>/</code>(slash)。</p>
<p>内核会为每个进程保存当前工作目录(cwd, current working directory)，可以用 <code>cd</code> 命令来进行更改。我们通过路径名来确定文件的位置，一般分为绝对路径和相对路径。</p>
<p>接下来我们了解一下基本的文件操作。</p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在使用文件之前需要通知内核打开该文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fd; // 文件描述符 file descriptor</span><br><span class="line"></span><br><span class="line">if ((fd = open(&quot;/etc/hosts&quot;, O_RDONLY)) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;open&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>返回值是一个小的整型称为文件描述符(file descriptor)，如果这个值等于 -1 则说明发生了错误。每个由 Linux shell(注：感谢网友 yybear 的勘误) 创建的进程都会默认打开三个文件（注意这里的文件概念）：</p>
<ul>
<li>0: standard input(stdin)</li>
<li>1: standard output(stdout)</li>
<li>2: standar error(stderr)</li>
</ul>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>使用完毕之后同样需要通知内核关闭文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int fd;     // 文件描述符</span><br><span class="line">int retval; // 返回值</span><br><span class="line"></span><br><span class="line">int ((retval = close(fd)) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;close&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>如果在此关闭已经关闭了的文件，会出大问题。所以一定要检查返回值，哪怕是 <code>close()</code> 函数（如上面的例子所示）</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>在打开和关闭之间就是读取文件，实际上就是把文件中对应的字节复制到内存中，并更新文件指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char buf[512];</span><br><span class="line">int fd;</span><br><span class="line">int nbytes;</span><br><span class="line"></span><br><span class="line">// 打开文件描述符，并从中读取 512 字节的数据</span><br><span class="line">if ((nbytes = read(fd, buf, sizeof(buf))) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;read&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>返回值是读取的字节数量，是一个 <code>ssize_t</code> 类型（其实就是一个有符号整型），如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>写入文件是把内存中的数据复制到文件中，并更新文件指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char buf[512];</span><br><span class="line">int fd;</span><br><span class="line">int nbytes;</span><br><span class="line"></span><br><span class="line">// 打开文件描述符，并向其写入 512 字节的数据</span><br><span class="line">if ((nbytes = write(fd, buf, sizeof(buf)) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    perror(&quot;write&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>返回值是写入的字节数量，如果 <code>nbytes &lt; 0</code> 那么表示出错。<code>nbytes &lt; sizeof(buf)</code> 这种情况(short counts) 是可能发生的，而且并不是错误。</p>
<p>综合上面的操作，我们可以来看看 Unix I/O 的例子，这里我们一个字节一个字节把标准输入复制到标准输出中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    while(Read(STDIN_FILENO, &amp;c, 1) != 0)</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, 1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>前面提到的 short count 会在下面的情形下发生：</p>
<ul>
<li>在读取的时候遇到 EOF(end-of-file)</li>
<li>从终端中读取文本行</li>
<li>读取和写入网络 sockets</li>
</ul>
<p>但是在下面的情况下不会发生</p>
<ul>
<li>从磁盘文件中读取（除 EOF 外）</li>
<li>写入到磁盘文件中</li>
</ul>
<p>最好总是允许 short count，这样就可以避免处理这么多不同的情况。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>元数据是用来描述数据的数据，由内核维护，可以通过 <code>stat</code> 和 <code>fstat</code> 函数来访问，其结构是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct stat</span><br><span class="line">&#123;</span><br><span class="line">    dev_t           st_dev;     // Device</span><br><span class="line">    ino_t           st_ino;     // inode</span><br><span class="line">    mode_t          st_mode;    // Protection &amp; file type</span><br><span class="line">    nlink_t         st_nlink;   // Number of hard links</span><br><span class="line">    uid_t           st_uid;     // User ID of owner</span><br><span class="line">    gid_t           st_gid;     // Group ID of owner</span><br><span class="line">    dev_t           st_rdev;    // Device type (if inode device)</span><br><span class="line">    off_t           st_size;    // Total size, in bytes</span><br><span class="line">    unsigned long   st_blksize; // Blocksize for filesystem I/O</span><br><span class="line">    unsigned long   st_blocks;  // Number of blocks allocated</span><br><span class="line">    time_t          st_atime;   // Time of last access</span><br><span class="line">    time_t          st_mtime;   // Time of last modification</span><br><span class="line">    time_t          st_ctime;   // Time of last change</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>对应的访问例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main (int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    struct stat stat;</span><br><span class="line">    char *type, *readok;</span><br><span class="line">    </span><br><span class="line">    Stat(argv[1], &amp;stat);</span><br><span class="line">    if (S_ISREG(stat.st_mode)) // 确定文件类型</span><br><span class="line">        type = &quot;regular&quot;;</span><br><span class="line">    else if (S_ISDIR(stat.st_mode))</span><br><span class="line">        type = &quot;directory&quot;;</span><br><span class="line">    else</span><br><span class="line">        type = &quot;other&quot;;</span><br><span class="line">    </span><br><span class="line">    if ((stat.st_mode &amp; S_IRUSR)) // 检查读权限</span><br><span class="line">        readok = &quot;yes&quot;;</span><br><span class="line">    else</span><br><span class="line">        readok = &quot;no&quot;;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;type: %s, read: %s\n&quot;, type, readok);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>了解了具体的结构之后，我们来看看内核是如何表示已打开的文件的。其实过程很简单，每个进程都有自己的描述符表(Descriptor table)，然后 Descriptor 1 指向终端，Descriptor 4 指向磁盘文件，如下图所示：</p>
<p><img src="14614963360280.jpg" alt="img"></p>
<p>这里有一个需要说明的情况，就是使用 <code>fork</code>。子进程实际上是会继承父进程打开的文件的。在 fork 之后，子进程实际上和父进程的指向是一样的，这里需要注意的是会把引用计数加 1，如下图所示</p>
<p><img src="14614966173879.jpg" alt="img"></p>
<p>了解了这个，我们我们就可以知道所谓的重定向是怎么实现的了。其实很简单，只要调用 <code>dup2(oldfd, newfd)</code> 函数即可。我们只要改变文件描述符指向的文件，也就完成了重定向的过程，下图中我们把原来指向终端的文件描述符指向了磁盘文件，也就把终端上的输出保存在了文件中：</p>
<p><img src="14614968463687.jpg" alt="img"></p>
<h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>C 标准库中包含一系列高层的标准 IO 函数，比如</p>
<ul>
<li>打开和关闭文件: <code>fopen</code>, <code>fclose</code></li>
<li>读取和写入字节: <code>fread</code>, <code>fwrite</code></li>
<li>读取和写入行: <code>fgets</code>, <code>fputs</code></li>
<li>格式化读取和写入: <code>fscanf</code>, <code>fprintf</code></li>
</ul>
<p>标准 IO 会用流的形式打开文件，所谓流(stream)实际上是文件描述符和缓冲区(buffer)在内存中的抽象。C 程序一般以三个流开始，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">extern FILE *stdin;     // 标准输入 descriptor 0</span><br><span class="line">extern FILE *stdout;    // 标准输出 descriptor 1</span><br><span class="line">extern FILE *stderr;    // 标准错误 descriptor 2</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stdout, &quot;Hello, Da Wang\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>接下来我们详细了解一下为什么需要使用缓冲区，程序经常会一次读入或者写入一个字符，比如 <code>getc</code>, <code>putc</code>, <code>ungetc</code>，同时也会一次读入或者写入一行，比如 <code>gets</code>, <code>fgets</code>。如果用 Unix I/O 的方式来进行调用，是非常昂贵的，比如说 <code>read</code> 和 <code>write</code> 因为需要内核调用，需要大于 10000 个时钟周期。</p>
<p>解决的办法就是利用 <code>read</code> 函数一次读取一块数据，然后再由高层的接口，一次从缓冲区读取一个字符（当缓冲区用完的时候需要重新填充）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/ch09/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/ch09/" itemprop="url">ch09</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-18T14:09:19+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虚拟内存</p>
<ol>
<li>了解物理地址和虚拟地址的区别</li>
<li>理解虚拟内存在缓存、内存管理与保护中所扮演的角色</li>
<li>掌握虚拟内存到物理内存的翻译机制</li>
<li>理解现代计算机系统中虚拟内存的应用</li>
<li>理解动态内存分配的基本概念</li>
<li>区别内部碎片与外部碎片</li>
<li>掌握管理动态内存分配的三种方法</li>
<li>了解垃圾回收的基本原理</li>
<li>了解内存使用中常见的错误</li>
</ol>
<p>这一讲的内容，跟之前介绍的缓存系统有异曲同工之妙，唯一的差别是，因为涉及的概念和横跨的系统层级增多，难度更大了。</p>
<h2 id="从物理内存到虚拟内存"><a href="#从物理内存到虚拟内存" class="headerlink" title="从物理内存到虚拟内存"></a>从物理内存到虚拟内存</h2><p>物理地址一般应用在简单的嵌入式微控制器中（汽车、电梯、电子相框等），因为应用的范围有严格的限制，不需要在内存管理中引入过多的复杂度。</p>
<p>但是对于计算机（以及其他智能设备）来说，虚拟地址则是必不可少的，通过 MMU(Memory management unit)把虚拟地址(Virtual Address, VA)转换为物理地址(Physical Address, PA)，再由此进行实际的数据传输。</p>
<p>使用虚拟内存主要是基于下面三个考虑：</p>
<ol>
<li>可以更有效率的使用内存：使用 DRAM 当做部分的虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都有统一的线性地址空间</li>
<li>隔离地址控件：进程之间不会相互影响；用户程序不能访问内核信息和代码</li>
</ol>
<h2 id="虚拟内存的三个角色"><a href="#虚拟内存的三个角色" class="headerlink" title="虚拟内存的三个角色"></a>虚拟内存的三个角色</h2><h3 id="作为缓存工具"><a href="#作为缓存工具" class="headerlink" title="作为缓存工具"></a>作为缓存工具</h3><p>概念上来说，虚拟内存就是存储在磁盘上的 N 个连续字节的数组。这个数组的部分内容，会缓存在 DRAM 中，在 DRAM 中的每个缓存块(cache block)就称为页(page)</p>
<h3 id="作为内存管理工具"><a href="#作为内存管理工具" class="headerlink" title="作为内存管理工具"></a>作为内存管理工具</h3><p>每个进程都有自己的虚拟地址空间，这样一来，对于进程来说，它们看到的就是简单的线性空间（但实际上在物理内存中可能是间隔、支离破碎的）</p>
<p>在内存分配中没有太多限制，每个虚拟页都可以被映射到任何的物理页上。这样也带来一个好处，如果两个进程间有共享的数据，那么直接指向同一个物理页即可</p>
<h3 id="作为内存保护工具"><a href="#作为内存保护工具" class="headerlink" title="作为内存保护工具"></a>作为内存保护工具</h3><p>页表中的每个条目的高位部分是表示权限的位，MMU 可以通过检查这些位来进行权限控制（读、写、执行）</p>
<h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><p>开始之前先来了解以下参数：</p>
<p>N=2n,M=2m,P=2pN=2n,M=2m,P=2p</p>
<p>其中 <code>N</code> 表示虚拟地址空间中的地址数量，<code>M</code> 表示物理地址空间中的地址数量，<code>P</code> 是每一页包含的字节数(page size)。</p>
<p>虚拟地址(VA, Virtual Address)中的元素：</p>
<ul>
<li><code>TLBI</code>: TLB 的索引值</li>
<li><code>TLBT</code>: TLB 的标签(tag)</li>
<li><code>VPO</code>: 虚拟页偏移量</li>
<li><code>VPN</code>: 虚拟页编号</li>
</ul>
<p>物理地址(PA, physical address)中的元素：</p>
<ul>
<li><code>PPO</code>: 物理页偏移量（与 <code>VPO</code> 的值相同）</li>
<li><code>PPN</code>: 物理页编号</li>
</ul>
<p>然后我们通过一个具体的例子来说明如何进行地址翻译</p>
<h3 id="多层页表-Multi-Level-Page-Table"><a href="#多层页表-Multi-Level-Page-Table" class="headerlink" title="多层页表 Multi-Level Page Table"></a>多层页表 Multi-Level Page Table</h3><p>虽然页表是一个表，但因为往往虚拟地址的位数比物理内存的位数要大得多，所以保存页表项(PTE) 所需要的空间也是一个问题。举个例子：</p>
<p>假设每个页的大小是 4KB（2 的 12 次方），每个地址有 48 位，一条 PTE 记录有 8 个字节，那么要全部保存下来，需要的大小是：</p>
<p>248×2−12×23=239bytes248×2−12×23=239bytes</p>
<p>整整 512 GB！所以我们采用多层页表，第一层的页表中的条目指向第二层的页表，一个一个索引下去，最终寻找具体的物理地址，</p>
<h3 id="地址翻译实例"><a href="#地址翻译实例" class="headerlink" title="地址翻译实例"></a>地址翻译实例</h3><p>来看一个简单的例子，我们的内存系统设定如下：</p>
<ul>
<li>14 位的虚拟地址</li>
<li>12 位的物理地址</li>
<li>页大小为 64 字节</li>
</ul>
<p>TLB 的配置为：</p>
<ul>
<li>能够存储 16 条记录</li>
<li>每个集合有 4 条记录</li>
</ul>
<p>系统本身缓存（对应于物理地址）：</p>
<ul>
<li>16 行，每个块 4 个字节</li>
<li>直接映射（即 16 个集合）</li>
</ul>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>前面了解了虚拟内存的相关知识，这一节我们来看看动态内存分配的基本概念，相信这之后就知道诸如 <code>malloc</code> 和 <code>new</code> 这类方法是怎么做的了。</p>
<p>程序员通过动态内存分配（例如 <code>malloc</code>）来让程序在运行时得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，称为堆(heap)。</p>
<p>分配器以块为单位来维护堆，可以进行分配或释放。有两种类型的分配器：</p>
<ul>
<li>显式分配器：应用分配并且回收空间（C 语言中的 <code>malloc</code> 和 <code>free</code>）</li>
<li>隐式分配器：应用只负责分配，但是不负责回收（Java 中的垃圾收集）</li>
</ul>
<p>先来看看一个简单的使用 <code>malloc</code> 和 <code>free</code> 的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo(int n) &#123;</span><br><span class="line">    int i, *p;</span><br><span class="line">    </span><br><span class="line">    /* Allocate a block of n ints */</span><br><span class="line">    p = (int *) malloc(n * sizeof(int));</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        perror(&quot;malloc&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /* Initialize allocated block */</span><br><span class="line">    for (i=0; i&lt;n; i++)</span><br><span class="line">        p[i] = i;</span><br><span class="line"></span><br><span class="line">    /* Return allocated block to the heap */</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>我们已经知道了原理，现在就来看看怎么样能够实现一个高效的内存分配算法吧！在具体实现之前，需要考虑以下问题：</p>
<ul>
<li>给定一个指针，我们如何知道需要释放多少内存？</li>
<li>如何记录未分配的块？</li>
<li>实际需要的空间比未分配的空间要小的时候，剩下的空间怎么办？</li>
<li>如果有多个区域满足条件，如何选择？</li>
<li>释放空间之后如何进行记录？</li>
</ul>
<p>具体这部分书中提到了四种方法：</p>
<ol>
<li>隐式空闲列表 Implicit List</li>
<li>显式空闲列表 Explicit List</li>
<li>分离的空闲列表 Segregated Free List</li>
<li>按照大小对块进行排序 Blocks Sorted by Size</li>
</ol>
<p>因为涉及的细节比较多，建议是详读书本的对应章节（第二版和第三版均为第九章第九节），这里不再赘述（如果需要的话之后我在另起一篇做详细介绍）</p>
<p>这里提一点，就是如何确定哪部分空间合适，有三种方法：</p>
<ol>
<li>First Fit: 每次都从头进行搜索，找到第一个合适的块，线性查找</li>
<li>Next Fit: 每次从上次搜索结束的位置继续搜索，速度较快，但可能会有更多碎片</li>
<li>Best Fit: 每次遍历列表，找到最合适的块，碎片较少，但是速度最慢</li>
</ol>
<p>更详细可以参考这两篇文章：<a href="http://wdxtub.com/vault/csapp-18.html" target="_blank" rel="noopener">Dynamic Memory Allocation - Basic Concept</a> 和 <a href="http://wdxtub.com/vault/csapp-19.html" target="_blank" rel="noopener">Dynamic Memory Allocation - Advanced Concept</a></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>所谓垃圾回收，就是我们不再需要显式释放所申请内存空间了，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">    int *p = malloc(128);</span><br><span class="line">    return; /* p block is now garbage*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>这种机制在许多动态语言中都有实现：Python, Ruby, Java, Perl, ML, Lisp, Mathematica。C 和 C++ 中也有类似的变种，但是需要注意的是，是不可能回收所有的垃圾的。</p>
<p>我们如何知道什么东西才是『垃圾』呢？简单！只要没有任何指针指向的地方，不管有没有用，因为都不可能被使用，当然可以直接清理掉啦。不过这其实是需要一些前提条件的：</p>
<ul>
<li>我们可以知道哪里是指针，哪里不是指针</li>
<li>每个指针都指向 block 的开头</li>
<li>指针不能被隐藏(by coercing them to an <code>int</code>, and then back again)</li>
</ul>
<p>相关的算法如下：</p>
<ul>
<li>Mark-and-sweep collection (McCarthy, 1960)</li>
<li>Reference counting (Collins, 1960)</li>
<li>Copying collection (Minsky, 1963)</li>
<li>Generational Collectors(Lieberman and Hewitt, 1983)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们先了解了物理地址和虚拟地址的区别，然后在此基础上理解虚拟内存在缓存、内存管理与保护中所扮演的角色，并通过实际的例子学习虚拟内存到物理内存的翻译机制。</p>
<p>有了前面的基础，简要介绍了动态内存分配的基本概念和管理动态内存分配的三种算法。最后提及了垃圾回收的基本原理和内存使用中常见的错误。</p>
<p>尤其是动态内存分配和垃圾回收的部分，因为篇幅限制说得比较简单，一定要对照书本进行阅读和理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/ch08/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/ch08/" itemprop="url">ch08</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-18T14:03:50+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>异常控制流</p>
<ol>
<li>了解异步异常与同步异常，以及异常控制流与平时的逻辑控制流的差异</li>
<li>理解进程的工作机制，如何通过异常来进行进程切换</li>
<li>理解 Linux 的进程控制机制，掌握 <code>fork</code> 的基本用法</li>
<li>了解信号的基本原理以及如何处理信号</li>
<li>掌握如何避免进程竞争的方法</li>
<li>了解非本地跳转的概念和意义</li>
</ol>
<p>进程可能是计算机系统中最伟大的抽象。进程这个概念背后，其实隐藏着一整套系统级机制，从进程切换、用户态与内核态的转换到系统实时响应各种事件，都离不开一个相当熟悉又陌生的概念——异常。在这个基础上，我们会一起来看看，操作系统到底是如何工作的，为什么可以同时执行不同的程序，具体又是通过什么机制来管理这一切的呢？</p>
<h2 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h2><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 Exception"></a>异常 Exception</h2><p>这里的异常指的是把控制交给系统内核来响应某些事件（例如处理器状态的变化），其中内核是操作系统常驻内存的一部分，而这类事件包括除以零、数学运算溢出、页错误、I/O 请求完成或用户按下了 ctrl+c 等等系统级别的事件。</p>
<h3 id="异步异常（中断）"><a href="#异步异常（中断）" class="headerlink" title="异步异常（中断）"></a>异步异常（中断）</h3><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><h3 id="系统调用示例"><a href="#系统调用示例" class="headerlink" title="系统调用示例"></a>系统调用示例</h3><table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center"><code>read</code></td>
<td style="text-align:center">读取文件</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>write</code></td>
<td style="text-align:center">写入文件</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>open</code></td>
<td style="text-align:center">打开文件</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>close</code></td>
<td style="text-align:center">关闭文件</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>stat</code></td>
<td style="text-align:center">获取文件信息</td>
</tr>
<tr>
<td style="text-align:center">57</td>
<td style="text-align:center"><code>fork</code></td>
<td style="text-align:center">创建进程</td>
</tr>
<tr>
<td style="text-align:center">59</td>
<td style="text-align:center"><code>execve</code></td>
<td style="text-align:center">执行一个程序</td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td style="text-align:center"><code>_exit</code></td>
<td style="text-align:center">关闭进程</td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center"><code>kill</code></td>
<td style="text-align:center">向进程发送信号</td>
</tr>
</tbody>
</table>
<h3 id="故障示例"><a href="#故障示例" class="headerlink" title="故障示例"></a>故障示例</h3><p>这里我们以 Page Fault 为例，来说明 Fault 的机制。Page Fault 发生的条件是：</p>
<ul>
<li>用户写入内存位置</li>
<li>但该位置目前还不在内存中</li>
</ul>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[1000];</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    a[500] = 13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>那么系统会通过 Page Fault 把对应的部分载入到内存中，然后重新执行赋值语句：</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是计算机科学中最为重要的思想之一，进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 创建子进程</span><br><span class="line">linux&gt; ./forks 16</span><br><span class="line">Child1: pid=24818 pgrp=24817</span><br><span class="line">Child2: pid=24819 pgrp=24817</span><br><span class="line"># 查看进程</span><br><span class="line">linux&gt; ps</span><br><span class="line">  PID TTY      TIME  CMD</span><br><span class="line">24788 pts/2 00:00:00 tcsh</span><br><span class="line">24818 pts/2 00:00:02 forks</span><br><span class="line">24819 pts/2 00:00:02 forks</span><br><span class="line">24820 pts/2 00:00:00 ps</span><br><span class="line"></span><br><span class="line"># 可以选择关闭某个进程</span><br><span class="line">linux&gt; /bin/kill -9 24818</span><br><span class="line"># 也可以关闭某个进程组，会关闭该组中所有进程</span><br><span class="line">linux&gt; /bin/kill -9 -24817</span><br><span class="line"># 查看进程</span><br><span class="line">linux&gt; ps</span><br><span class="line">  PID TTY      TIME  CMD</span><br><span class="line">24788 pts/2 00:00:00 tcsh</span><br><span class="line">24820 pts/2 00:00:00 ps</span><br></pre></td></tr></table></figure>
<h3 id="进程控制-Process-Control"><a href="#进程控制-Process-Control" class="headerlink" title="进程控制 Process Control"></a>进程控制 Process Control</h3><h2 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号 Signal"></a>信号 Signal</h2><p>Linux 的进程树，可以通过 <code>pstree</code> 命令查看</p>
<p>编号名称默认动作对应事件2SIGINT终止用户输入 ctrl+c9SIGKILL终止终止程序（不能重写或忽略）11SIGSEGV终止且 Dump段冲突 Segmentation violation14SIGALRM终止时间信号17SIGCHLD忽略子进程停止或终止</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">默认动作</th>
<th style="text-align:center">对应事件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">SIGINT</td>
<td style="text-align:center">终止</td>
<td style="text-align:center">用户输入 ctrl+c</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">SIGKILL</td>
<td style="text-align:center">终止</td>
<td style="text-align:center">终止程序（不能重写或忽略）</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">SIGSEGV</td>
<td style="text-align:center">终止且 Dump</td>
<td style="text-align:center">段冲突 Segmentation violation</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">SIGALRM</td>
<td style="text-align:center">终止</td>
<td style="text-align:center">时间信号</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">SIGCHLD</td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">子进程停止或终止</td>
</tr>
</tbody>
</table>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都只属于一个进程组，从前面的进程树状图中我们也能大概了解一二，想要了解相关信息，一般使用如下函数：</p>
<ul>
<li><code>getpgrp()</code> - 返回当前进程的进程组</li>
<li><code>setpgid()</code> - 设置一个进程的进程组</li>
</ul>
<p>我们可以据此指定一个进程组或者一个单独的进程，比方说可以通过 <code>kill</code> 应用来发送信号，流入这里可以看到，第一个命令只会杀掉编号为 24818 的进程，但是第二个命令，因为有两个进程都属于进程组 24817，所以会杀掉进程组中的每个进程。</p>
<p>STAT 部分的第一个字母的意思</p>
<ul>
<li>S: 睡眠 sleeping</li>
<li>T: 停止 stopped</li>
<li>R: 运行 running</li>
</ul>
<p>第二个字母的意思：</p>
<ul>
<li>s: 会话管理者 session leader</li>
<li>+: 前台进程组</li>
</ul>
<p>更多信息可以查看 <code>man ps</code></p>
<h3 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h3><p>我们知道，内核会阻塞与当前在处理的信号同类型的其他正待等待的信号，也就是说，一个 SIGINT 信号处理器是不能被另一个 SIGINT 信号中断的。</p>
<p>如果想要显式阻塞，就需要使用 <code>sigprocmask</code> 函数了，以及其他一些辅助函数：</p>
<ul>
<li><code>sigemptyset</code> - 创建空集</li>
<li><code>sigfillset</code> - 把所有的信号都添加到集合中（因为信号数目不多）</li>
<li><code>sigaddset</code> - 添加指定信号到集合中</li>
<li><code>sigdelset</code> - 删除集合中的指定信号</li>
</ul>
<p>我们可以用下面这段代码来临时阻塞特定的信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sigset_t mask, prev_mask;</span><br><span class="line"></span><br><span class="line">Sigemptyset(&amp;mask); // 创建空集</span><br><span class="line">Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中</span><br><span class="line"></span><br><span class="line">// 阻塞对应信号，并保存之前的集合作为备份</span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line">...</span><br><span class="line">... // 这部分代码不会被 SIGINT 中断</span><br><span class="line">...</span><br><span class="line">// 取消阻塞信号，恢复原来的状态</span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲中，我们细致了解了而异常控制流的四个基本机制：异常、进程切换、信号和非本地跳转。其中异常是最底层的，也是后面几种的基础；而信号是进程间最重要，简单却强大的信使。结合信号和进程，因为系统进程并行的缘故，具体编写程序的时候有许多需要注意的地方。</p>
<p>这部分的内容比较繁杂，涉及到的相关概念也比较多，最好结合《深入理解计算机系统》的原文来进行学习。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/ch06/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/ch06/" itemprop="url">ch06</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-18T12:26:52+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存层次结构。</p>
<p>6.1 存储技术</p>
<p>RAM random access memory</p>
<p>分为SRAM 和 DRAM</p>
<p>介绍各种增强型DRAM的种类。</p>
<p>磁盘存储</p>
<p>介绍磁盘的物理结构。</p>
<p>虽然现在越来越多电脑已经改为使用固态硬盘，但是还是有必要了解一下硬盘的组成的</p>
<p>介绍固态硬盘。</p>
<p>固态硬盘中分成很多的块(Block)，每个块又有很多页(Page)，大约 32-128 个，每个页可以存放一定数据（大概 4-512KB），页是进行数据读写的最小单位。但是有一点需要注意，对一个页进行写入操作的时候，需要先把整个块清空（设计限制），而一个块大概在 100,000 次写入之后就会报废。</p>
<p>与传统的机械硬盘相比，固态硬盘在读写速度上有很大的优势。但是因为设计本身的约束，连续访问会比随机访问快，而且如果需要写入 Page，那么需要移动其他 Page，擦除整个 Block，然后才能写入。现在固态硬盘的读写速度差距已经没有以前那么大了，但是仍然有一些差距。</p>
<p>总线</p>
<p>总线是用来传输地址、数据和控制信号的一组平行的电线，通常来说由多个设备共享，类似于不同城市之间的高速公路，可以传输各类数据。CPU 通过总线和对应的接口来从不同的设备中获得所需要的数据，放入寄存器中等待运算。</p>
<p>局部性原理</p>
<p>局部性的思路很简单[2]：</p>
<ul>
<li>时间局部性(Temporal Locality): 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。</li>
<li>空间局部性(Spatial Locality): 在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的</li>
<li>顺序局部性(Order Locality): 在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型数组访问也是顺序的。指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。</li>
</ul>
<p>存储体系</p>
<p>一种介质的速度越快就会越贵，同时也消耗更多的电量，所以一般容量比较小。而 CPU 和内存之间的速度差距越来越大，所以好的程序都会尽可能利用局部性。而根据这些特性，引申出了安排存储的方式，称为金字塔式存储体系(Memory Hierarch)。</p>
<p>这里就涉及到一个技术：缓存。缓存可以看作是把大且缓慢的设备中的数据的一部分拿出来存储到其中的更快的存储设备。在金字塔式存储体系[3]中，每一层都可以看作是下一层的缓存。利用局部性原理，程序会更倾向于访问第 k 层的数据，而非第 k+1 层，这样就减少了访问时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/ch03/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/ch03/" itemprop="url">ch03</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-07T21:34:02+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>intel x86 的重要型号。</p>
<p>8086</p>
<p>i386</p>
<p>pentium 4E</p>
<p>core 2</p>
<p>core i7</p>
<p>摩尔定律</p>
<p>gcc -Og -o p p1.c p2.c</p>
<p>生成编译文件</p>
<p>gcc -Og -S mstore.c</p>
<p>gcc -Og -c mstore.c</p>
<p>objdump -d mstore.o</p>
<p>Byte  b</p>
<p>Word w</p>
<p>Double word l</p>
<p>Quad word q</p>
<p>整数寄存器</p>
<p>重要的几个</p>
<p>%rax  一般存返回值</p>
<p>%rsp  栈针</p>
<p>%rdi 第一个参数</p>
<p>%rsi  第二个参数</p>
<p>各种寻址方式</p>
<p>立即寻址，寄存器寻址、内存寻址。</p>
<p>一般的形式为：</p>
<p>Imm(rb,ri,s)  =  Imm + R[rb]+ R[ri] * s</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Address   Computation</th>
<th>Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x8(%rdx)</td>
<td>0xf000 + 0x8</td>
<td>0xf008</td>
</tr>
<tr>
<td>(%rdx,%rcx)</td>
<td>0xf000 + 0x100</td>
<td>0xf100</td>
</tr>
<tr>
<td>(%rdx,%rcx,4)</td>
<td>0xf000 + 4*0x100</td>
<td>0xf400</td>
</tr>
<tr>
<td>0x80(,%rdx,2)</td>
<td>2*0xf000 + 0x80</td>
<td>0x1e080</td>
</tr>
</tbody>
</table>
<p>数据移动指令，move</p>
<p>类似于赋值？</p>
<p>§<strong>movq</strong> <strong>(**</strong>%<strong><strong>r</strong></strong>cx<strong><strong>),</strong></strong>%<strong><strong>r</strong></strong>ax**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void swap</span><br><span class="line">   (long *xp, long *yp) </span><br><span class="line">&#123;</span><br><span class="line">  long t0 = *xp;</span><br><span class="line">  long t1 = *yp;</span><br><span class="line">  *xp = t1;</span><br><span class="line">  *yp = t0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap:</span><br><span class="line">   movq    (%rdi), %rax</span><br><span class="line">   movq    (%rsi), %rdx</span><br><span class="line">   movq    %rdx, (%rdi)</span><br><span class="line">   movq    %rax, (%rsi)</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>入栈与出栈</p>
<p>pushq S</p>
<p>popq D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long m12(long x)</span><br><span class="line">&#123;</span><br><span class="line">  return x*12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leaq (%rdi,%rdi,2), %rax # t &lt;- x+x*2</span><br><span class="line">salq $2, %rax            # return t&lt;&lt;2</span><br></pre></td></tr></table></figure>
<p>算术运算与逻辑运算</p>
<p>一堆指令</p>
<p> Load Effective Address 与 move 类似</p>
<p>一元、二元运算符</p>
<p>incq  Dest  Dest = Dest + 1</p>
<p>decq  Dest  Dest = Dest - 1</p>
<p>negq  Dest  Dest = - Dest</p>
<p>notq  Dest  Dest = ~Dest</p>
<p>addq  Src,Dest  Dest = Dest + Src</p>
<p>subq  Src,Dest  Dest = Dest - Src</p>
<p>imulq  Src,Dest  Dest = Dest * Src</p>
<p>salq  Src,Dest  Dest = Dest &lt;&lt; Src  Also called shlq</p>
<p>sarq  Src,Dest  Dest = Dest &gt;&gt; Src  Arithmetic</p>
<p>shrq  Src,Dest  Dest = Dest &gt;&gt; Src  Logical</p>
<p>xorq  Src,Dest  Dest = Dest ^ Src</p>
<p>andq  Src,Dest  Dest = Dest &amp; Src</p>
<p>orq  Src,Dest  Dest = Dest | Src</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">long arith</span><br><span class="line">(long x, long y, long z)</span><br><span class="line">&#123;</span><br><span class="line">  long t1 = x+y;</span><br><span class="line">  long t2 = z+t1;</span><br><span class="line">  long t3 = x+4;</span><br><span class="line">  long t4 = y * 48;</span><br><span class="line">  long t5 = t3 + t4;</span><br><span class="line">  long rval = t2 * t5;</span><br><span class="line">  return rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arith:</span><br><span class="line">  leaq    (%rdi,%rsi), %rax   # t1</span><br><span class="line">  addq    %rdx, %rax          # t2</span><br><span class="line">  leaq    (%rsi,%rsi,2), %rdx</span><br><span class="line">  salq    $4, %rdx            # t4</span><br><span class="line">  leaq    4(%rdi,%rdx), %rcx  # t5</span><br><span class="line">  imulq   %rcx, %rax          # rval</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>移位操作</p>
<p>特殊的算术操作</p>
<p>总结：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">History of Intel processors and architectures</span><br><span class="line">	Evolutionary design leads to many quirks and artifacts</span><br><span class="line">C, assembly, machine code</span><br><span class="line">	New forms of visible state: program counter, registers, ...</span><br><span class="line">	Compiler must transform statements, expressions, procedures into low-level instruction sequences</span><br><span class="line">Assembly Basics: Registers, operands, move</span><br><span class="line">	The x86-64 move instructions cover wide range of data movement forms</span><br><span class="line">Arithmetic</span><br><span class="line">	C compiler will figure out different instruction combinations to carry out computation</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/ch02/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/ch02/" itemprop="url">ch02</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-07T20:38:24+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分了四小节。</p>
<p>第一小节主要讲用bit来表示信息。</p>
<p>0,1二进制计算机中电子信号很容易实现。</p>
<p>byte = 8bits。</p>
<p>int 4byte</p>
<p>long 8byte.</p>
<p>布尔计算</p>
<p>And Or Not Xor</p>
<p>逻辑运算 </p>
<p>&amp;&amp; || !</p>
<p>移位操作</p>
<p>左移，逻辑右移和算术右移</p>
<p>第二部分讲整数的表示，第三部分讲整数的讲整数运算</p>
<p>无符号数</p>
<p><img src="image-20191007211241261.png" alt="image-20191007211241261"></p>
<p>补码</p>
<p><img src="image-20191007211330693.png" alt="image-20191007211330693"></p>
<p>UMin  =  0</p>
<p>UMax   =   2<em>w</em>– 1</p>
<p><em>TMin</em>  =   –2<em>w</em>–1</p>
<p><em>TMax</em>   =   2<em>w</em>–1 – 1</p>
<p><strong>casting</strong>, 无符号数和补码间的转化</p>
<p><strong>Bit pattern is maintained</strong></p>
<p><strong>But reinterpreted</strong></p>
<p><strong>Can have unexpected effects: adding or subtracting 2^w</strong></p>
<p><strong>Expanding, truncating</strong></p>
<p><strong>Expanding (e.g., short</strong> <strong>int</strong> <strong>to</strong> <strong>int</strong>)</p>
<p>Unsigned: zeros added</p>
<p>Signed: sign extension</p>
<p>Both yield expected result</p>
<p><strong>Truncating (e.g., unsigned to unsigned short)</strong></p>
<p>Unsigned/signed: bits are truncated</p>
<p>Result reinterpreted</p>
<p>Unsigned: mod operation</p>
<p>Signed: similar to mod</p>
<p>For small numbers yields expected behavior</p>
<p>加法、减法、乘法、移位</p>
<p>无符号数加法</p>
<p><em>s</em>  =   UAdd<em>w</em>(<em>u</em> , <em>v</em>)  =  <em>u</em> + <em>v</em> mod 2^<em>w</em></p>
<p>补码加法。</p>
<p>Mathematical addition + possible addition or subtraction of 2w</p>
<p>第四部分讲浮点数</p>
<p>IEEE Standard 754</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/01/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:54:22+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/ch01/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李玉">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李玉的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/01/ch01/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T21:41:59+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一章类似课程概览。</p>
<p>一本导论性质的书，涉及了编译、操作系统、网络、计算组成等主题。</p>
<p>计算机中的整数和浮点数的表示，与数学运算的区别。例如，运算溢出问题。</p>
<p>​        40000 * 40000  ➙ 1600000000</p>
<p>​        50000 * 50000  ➙ ??</p>
<p>汇编。</p>
<p>​    侧重读懂，不一定用汇编编程。对理解编译器的行为很有帮助，性能调优。</p>
<p>​    预处理，编译，汇编，链接。</p>
<p>内存相关的问题。</p>
<p>​    内存模型，很重要的东西。</p>
<p>​    C中，引用内存错误的问题很常见。</p>
<p>​    例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  int a[2];</span><br><span class="line">  double d;</span><br><span class="line">&#125; struct_t;</span><br><span class="line"></span><br><span class="line">double fun(int i) &#123;</span><br><span class="line">  volatile struct_t s;</span><br><span class="line">  s.d = 3.14;</span><br><span class="line">  s.a[i] = 1073741824; /* Possibly out of bounds */</span><br><span class="line">  return s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fun(0)  ➙  3.14</p>
<p>fun(1)  ➙  3.14</p>
<p>fun(2)  ➙  3.1399998664856</p>
<p>fun(3)  ➙  2.00000061035156</p>
<p>fun(4)  ➙  3.14</p>
<p>fun(6)  ➙  Segmentation fault</p>
<p>性能调优。从而去了解计算机体系结构等的方方面面。例如下面两段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void copyij(int src[2048][2048],</span><br><span class="line">            int dst[2048][2048])</span><br><span class="line">&#123;</span><br><span class="line">  int i,j;</span><br><span class="line">  for (i = 0; i &lt; 2048; i++)</span><br><span class="line">    for (j = 0; j &lt; 2048; j++)</span><br><span class="line">      dst[i][j] = src[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void copyji(int src[2048][2048],</span><br><span class="line">            int dst[2048][2048])</span><br><span class="line">&#123;</span><br><span class="line">  int i,j;</span><br><span class="line">  for (j = 0; j &lt; 2048; j++)</span><br><span class="line">    for (i = 0; i &lt; 2048; i++)</span><br><span class="line">      dst[i][j] = src[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算机网络。</p>
<p>​    I/O。</p>
<p>​    讨论一些跨平台，并发等问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李玉</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李玉</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
